# -*- coding: utf-8 -*-
"""Python Challenge-8Queens Chess Problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hqZ3Er-IGfP0eXdNefYMtfs94r9ztTfs

Description: Problem

The eight queens puzzle is the problem of placing eight chess queens on an 8Ã—8 chessboard so that no two queens threaten each other; thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general n queens problem of placing n non-attacking queens on an nxn chessboard. 

Challenge The challenge is to generate one right sequence through Genetic Programming. The sequence has to be 8 numbers between 0 to 7. Each number represents the positions the Queens can be placed. Each number refers to the row number in the specific column

0    3    4    5    6    1    2    4

0 is the row number in the column 0 where the Queen can be placed.

3 is the row number in the column 1 where the Queen can be placed.
"""

# import necessary libraries
import random

class EightQueens:
    def __init__(self, n, population , mutationRate):
        self.n = n
        self.mutationRate = mutationRate
        self.population = population
        
        
    def fitness(self,chromosome):
        ##'''fitness fn is proportional to the number of clashes amongst the queens. 
        #If seen, there are 28 clashes possible in an 8 x 8 chessboard. 
        #Therefore, if an individual has high fitness, then we could say it will have lower number of clashes.'''
        
        horizontal_collisions = sum([chromosome.count(queen)-1 for queen in chromosome])/2
        diagonal_collisions = 0

        n = len(chromosome)
        left_diagonal = [0] * 2*n
        right_diagonal = [0] * 2*n
        for i in range(n):
            left_diagonal[i + chromosome[i] - 1] += 1
            right_diagonal[len(chromosome) - i + chromosome[i] - 2] += 1

        diagonal_collisions = 0
        for i in range(2*n-1):
            counter = 0
            if left_diagonal[i] > 1:
                counter += left_diagonal[i]-1
            if right_diagonal[i] > 1:
                counter += right_diagonal[i]-1
            diagonal_collisions += counter / (n-abs(i-n+1))
            
        return int(maxFitness - (horizontal_collisions + diagonal_collisions)) #28-(2+3)=23
    
    @staticmethod
    def probability(chromosome, fitness):
        return fitness(chromosome) / maxFitness

    @staticmethod
    def random_pick(population, probabilities):
        populationWithProbabilty = zip(population, probabilities)
        total = sum(w for c, w in populationWithProbabilty)
        r = random.uniform(0, total)
        upto = 0
        for c, w in zip(population, probabilities):
            if upto + w >= r:
                return c
            upto += w
        assert False, "error"
    
    @staticmethod
    def cross_over(x, y): #doing cross_over between two chromosomes
        n = len(x)
        c = random.randint(0, n - 1)
        return x[0:c] + y[c:n]

    @staticmethod
    def mutation(x):  #randomly changing the value of a random index of a chromosome
        n = len(x)
        c = random.randint(0, n - 1)
        m = random.randint(0, n-1)
        x[c] = m
        return x

    
    def genetic_queen(self,population, fitness,mutationRate):
        new_population = []
        probabilities = [self.probability(n, fitness) for n in population]
        for i in range(len(population)):
            x = self.random_pick(population, probabilities) #best chromosome 1
            y = self.random_pick(population, probabilities) #best chromosome 2
            child = self.cross_over(x, y) #creating new chromosomes from the best 2 chromosomes
            if random.random() < mutationRate:
                child = self.mutation(child)
            new_population.append(child)
            if fitness(child) == maxFitness: break
        return new_population

if __name__ == "__main__":
    
    maxFitness = (8*(8-1))/2  # 8*7/2 = 28 classes possible in 8x8 chess board
    mutationRate = 0.01
    totalpopulation = 100
    n=8
    
    def random_chromosome(size): #making random chromosomes 
        return [random.randint(0, size-1) for _ in range(size) ]
    
    population = [random_chromosome(n) for _ in range(totalpopulation)]
    
    q = EightQueens(n,population, mutationRate)
    
    generation = 1

    while not maxFitness in [q.fitness(chrom) for chrom in population]:
        population = q.genetic_queen(population, q.fitness,mutationRate)
        generation += 1
    chrom_out = []
    print("Solved in Generation {}!".format(generation-1))
    for chrom in population:
        if q.fitness(chrom) == maxFitness:
            print("");
            print("One of the solutions: ")
            chrom_out = chrom
            print("Chromosome = {},  Fitness = {}".format(str(chrom), q.fitness(chrom)))